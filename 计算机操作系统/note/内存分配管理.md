
### 连续分配管理方式

连续分配：指为用户进程分配的必须是一个连续的内存空间
#### 单一连续分配

在单一连续分配方式中，内存被分为系统区和用户区；系统区通常位于内存的低地址部分，用于存放操作系统相关数据，用户区用于存放用户进程相关数据；内存中只能有一道用户程序，用户程序独占整个用户区空间

- 特点
优点：实现简单；无外部碎片；可以采用覆盖技术扩充内存；不一定需要采取内存保护
缺点：只能用于单用户、单任务的操作系统中；有内部碎片；存储器利用率极低
#### 固定分区分配

将整个用户空间划分为若干个固定大小的分区，在每个分区中只装入一道程序

操作系统需要建立一个数据结构：分区说明表，来实现各个分区的分配与回收；每个表项对应一个分区，通常按分区大小排列，每个表项包括对应分区的大小、起始地址、状态(是否已分配)

- 分区大小相等
缺乏灵活性，但是很适合用于用一台计算机控制多个相同对象的场合
- 分区大小不等
增加了灵活性，可以满足不同大小的进程需求；根据常在系统中运行的作业大小情况进行划分

- 特点
优点：实现简单，无外部碎片
缺点：当用户程序太大时，可能所有的分区都不能满足需求，此时不得不采
用覆盖技术来解决，但这又会降低性能；会产生内部碎片，内存利用率低
#### 动态分区分配

动态分区分配(可变分区分配)；这种分配方式不会预先划分内存分区，而是在进程装入内存时根据进程的大小动态地建立分区，并使分区的大小正好适合进程的需要，因此系统分区的大小和数目是可变的

- 空闲分区表
每个空闲分区对应一个表项，表项中包含分区号、分区大小、分区起始地址等信息
- 空闲分区链
每个分区的起始部分和末尾部分分别设置前向指针和后向指针，起始部分处还可记录分区大小等信息

- 特点
动态分区分配没有内部碎片，但是有外部碎片；可以通过紧凑(拼凑Compaction)技术来解决外部碎片

##### 动态分区分配算法

- 首次适应算法(First Fit)
空闲分区以**地址递增的次序排列**，每次分配内存时顺序查找空闲分区链(或空闲分区表)，找到大小能满足要求的第一个空闲分区

优点：综合看性能最好；算法开销小，回收分区后一般不需要对空闲分区队列重新排序

- 最佳适应算法(Best Fit)
空闲分区按**容量递增次序排列**，每次分配内存时顺序查找空闲分区链(或空闲分区表)，找到大小能满足要求的第一个空闲分区

缺点：每次都选最小的分区进行分配，会留下越来越多的、很小的、难以利用的内存块，因此这种方法会产生很多的外部碎片

- 最坏适应算法(Worst Fit)
空闲分区按**容量递减次序排列**，每次分配内存时顺序查找空闲分区链(或空闲分区表)，找到大小能满足要求的第一个空闲分区

缺点：会导致较大的连续空闲区被迅速用完；如果之后有“大进程”到达，就没有内存分区可用了

- 邻近适应算法(Next Fit)
空闲分区以**地址递增的顺序排列**(可排成一个循环链表)，每次分配内存时从上次查找结束的位置开始查找空闲分区链(或空闲分区表)，找到大小能满足要求的第一个空闲分区

缺点：会使高地址的大分区也被用完
***
### 基本分页存储管理

#### 基本概念

将内存空间分为一个个大小相等的分区，每个分区就是一个“页框” (页框=页=内存块=物理块=物理页面)；每个页框有一个编号，即“页框号”(页框号=页帧号=内存块号=物理块号=物理页号)，页框号从0开始

将进程的逻辑地址空间也分为与页框大小相等的一个个部分每个部分称为一个“页”或“页面；每个页面也有一个编号，即“页号”，页号从0开始

操作系统以页框为单位为各个进程分配内存空间，进程的每个页面分别放入一个页框中；也就是说，进程的页面与内存的页框有一一对应的关系；各个页面不必连续存放，可以放到不相邻的各个页框中

操作系统为每个进程建立一张页表(注:页表通常存在PCB中)；一个进程对应一张页表，每个页表项由“页号”和“块号”组成，进程的每个页面对应一个页表项，页表记录进程页面和实际存放的内存块之间的映射关系

- 地址转换
页面在内存中的起始地址+页内偏移量=实际的物理地址(通过页号查询页表，可知页面在内存中的起始地址)

如果每个页面大小为$2^KB$，用二进制数表示逻辑地址则末尾K 位即为页内偏移量，其余部分就是页号
#### 基本变换机构

基本地址变换机构(用于实现逻辑地址到物理地址转换的一组硬件机构)可以借助进程的页表将逻辑地址转换为物理地址
通常会在系统中设置一个页表寄存器(PTR)，存放页表在内存中的起始地址F和页表长度M；进程未执行时，页表的始址 和 页表长度 放在进程控制块(PCB)中，当进程被调度时，操作系统内核会把它们放到页表寄存器中

页式管理中地址是一维的
实际应用中，通常使一个页框恰好能放入整数个页表项
为了方便找到页表项，页表一般是放在连续的内存块中的

- 逻辑地址A到物理地址E的变换过程
1、页面大小为L，计算页号P和页内偏移量W(如果用十进制数手算，则 P=A/L，W=A%L；但是在计算机实际运行时，逻辑地址结构是固定不变的，因此计算机硬件可以更快地得到二进制表示的页号、页内偏移量)
2、比较页号P 和页表长度M，若P>=M，则产生越界中断，否则继续执行(**页号是从0开始的，而页表长度至少是1，因此P=M时也会越界**)
3、页表中页号P对应的$页表项地址 = 页表起始地址F + 页号p \times 页表项长度$，取出该页表项内容b即为内存块号
4、计算$E=b\times L+W$，得到的物理地址E
#### 具有快表的地址变换机构

- 快表(TLB)
快表(联想寄存器，TLB， translation lookaside buffer)是一种访问速度比内存快很多的高速缓存(TLB不是内存)，用来存放最近访问的页表项的副本，可以加速地址变换的速度，与此对应，内存中的页表常称为慢表

- 地址变换过程
1、CPU给出逻辑地址，由某个硬件算得页号、页内偏移量，将页号与快表中的所有页号进行比较
2、如果找到匹配的页号，说明要访问的页表项在快表中有副本，则直接从中取出该页对应的内存块号，再将内存块号与页内偏移量拼接形成物理地址，最后，访问该物理地址对应的内存单元
3、如果没有找到匹配的页号，则需要访问内存中的页表，找到对应页表项，得到页面存放的内存块号，再将内存块号与页内偏移量拼接形成物理地址，最后，访问该物理地址对应的内存单元；因此，若快表未命中，则访问某个逻辑地址需要两次访存

- 局部性原理
因为局部性原理，一般来说快表的命中率可以达到90%以上

时间局部性：如果执行了程序中的某条指令，那么不久后这条指令很有可能再次执行；如果某个数据被访问过，不久之后该数据很可能再次被访问
空间局部性：一旦程序访问了某个存储单元，在不久之后，其附近的存储单元也很有可能被访问
#### 两级页表

- 单级页表存在的问题
页表必须连续存放，因此当页表很大时，需要占用很多个连续的页框；
根据局部性原理可知，很多时候，进程在一段时间内只需要访问某几个页面就可以正常运行，因此没有必要让整个页表都常驻内存

- 地址变换过程
1、按照地址结构将逻辑地址拆分成三部分
2、从PCB中读出页目录表始址，再根据一级页号查页目录表，找到下一级页表在内存中的存放位置
3、根据二级页号查表，找到最终想访问的内存块号
4、结合页内偏移量得到物理地址

- 多级页表
若采用多级页表机制，则各级页表的大小不能超过一个页面
***
### 基本分段存储管理

- 分段
按照程序自身的逻辑关系划分为若干个段，每个段都有一个段名(在低级语言
中，程序员使用段名来编程)，每段从0开始编址；
内存分配规则：以段为单位进行分配，每个段在内存中占据连续空间，但各段之间可以不相邻

分段系统的逻辑地址结构由段号(段号的位数决定了每个进程最多可以分几个段)和段内地址(段内地址位数决定了每个段的最大长度是多少)所组成

- 段表
每个段对应一个段表项(各个段表项的长度是相同的)，其中记录了该段在内存中的起始位置(又称“基址”) 和段的长度

- 地址变换过程
1、根据逻辑地址得到段号、段内地址
2、判断段号是否越界若段号S>=段表长度M，则产生越界中断，否则继续执行
3、查询段表，找到对应的段表项，$段表项的存放地址=段表起始地址F+段号S\times 段表项长度$
4、检查段内地址是否超过段长；若段内地址W>=段长C，则产生越界中断，否则继续执行
5、计算得到物理地址，访问目标内存单元

- 分段、分页存储管理的对比

| 分页         | 分段            |
| ---------- | ------------- |
| 信息的物理单位    | 信息的逻辑单位       |
| 对用户不可见     | 对用户可见         |
| 地址空间是一维的   | 地址空间是二维的      |
|            | 更容易实现信息的共享和保护 |
| 两次访存(快表一次) | 两次访存(快表一次)    |

***
### 基本段页式存储管理

- 分页/分段存储管理的优缺点
![[Pasted image 20240526160017.png]]

- 基本段页式存储管理
段页式系统的逻辑地址结构由段号(段号的位数决定了每个进程最多可以分几个段)、页号(页号位数决定了每个段最大有多少页)、页内地址(页内偏移量决定了页面大小、内存块大小是多少)组成

- 段表、页表
每个段对应一个段表项，每个段表项由段号、页表长度、页表存放块号(页表起始地址) 组成；每个段表项长度相等，段号是隐含的
每个页面对应一个页表项，每个页表项由页号、页面存放的内存块号组成；每个页表项长度相等，页号是隐含的

- 地址变换过程
1、由逻辑地址得到段号、页号、页内偏移量
2、段号与段表寄存器中的段长度比较，检查是否越界
3、由段表始址、段号找到对应段表项
4、根据段表中记录的页表长度，检查页号是否越界
5、由段表中的页表地址、页号得到查询页表，找到相应页表项
6、由页面存放的内存块号、页内偏移量得到最终的物理地址，访问目标单元
***
#### 地址转换

操作系统负责实现逻辑地址到物理地址的转换

- 三种装入方式
绝对装入：编译时产生绝对地扯
可重定位装入：装入时将逻辑地址转换为物理地址
动态运行时装入：运行时将逻辑地址转换为物理地址，需设置重定位寄存器
#### 存储保护

保证各进程在自己的内存空间内运行，不会越界访问

- 两种内存保护方法
方法一：在CPU中设置一对**上、下限寄存器**，存放进程的上、下限地址；进程的指令要访问某个地址时，CPU检查是否越界
方法二：采用**重定位寄存器 (基址寄存器)**和**界地址寄存器(限长寄存器)**进行越界检查；重定位寄存器中存放的是进程的起始物理地址，界地址寄
存器中存放的是进程的最大逻辑地址
***