
### 死锁的概念

#### 进程死锁、饥饿、死循环

- 死锁
在并发环境下，各进程因竞争资源而造成的一种**互相等待对方手里的资源，导致各进程都阻塞**，都无法向前推进的现象

- 饥饿
进程由于长期得不到想要的资源，某进程无法向前推进的现象

- 死循环
进程执行过程中一直跳不出某个循环的现象

#### 死锁产生的必要条件

产生死锁必须同时满足一下四个条件，其中任一条件不成立，死锁就不会发生

- 互斥条件
只有对必须互斥使用的资源的争抢才会导致死锁
- 不剥夺条件
进程所获得的资源在未使用完之前，不能由其他进程强行夺走，只能主动释放
- 请求和保持条件
进程已经保持了至少一个资源，但又提出了新的资源请求，而该资源又被其他进程占有，此时请求进程被阻塞，但又对自己已有的资源保持不放
- 循环等待条件
存在一种进程资源的循环等待链，链中的每一个进程已获得的资源同时被下一个进程所请求
#### 发生死锁的情况

对不可剥夺资源的不合理分配，可能导致死锁：
1、对系统资源的竞争
2、进程推进顺序非法，请求和释放资源的顺序不当
3、信号量的使用不当也会造成死锁
#### 死锁的处理策略

1、预防死锁：破坏死锁产生的四个必要条件中的一个或几个
2、避免死锁：用某种方法防止系统进入不安全状态，从而避免死锁
3、死锁的检测和解除：允许死锁的发生，不过操作系统会负责检测出死锁的发生，然后采取某种措施解除死锁
***
### 死锁预防

#### 破坏互斥条件

把只能互斥使用的资源改造为允许共享使用

- 缺点
可行性不高，很多时候无法破坏互斥条件
#### 破坏不剥夺条件

方案一：当某个进程请求新的资源得不到满足时，它必须立即释放保持的所有资源，待以后需要时再重新申请
方案二：当某个进程需要的资源被其他进程所占有的时候，可以由操作系统协助，将想要的资源强行剥夺

- 缺点
实现复杂，剥夺资源可能导致部分工作失效，反复申请和释放导致系统开销大，可能导致饥饿
#### 破坏请求和保持条件

静态分配方法：进程在运行前一次申请完它所需要的全部资源，在它的资源未满足前，不让它投入运行

- 缺点
资源利用率低，可能导致饥饿
#### 破坏循环等待条件

顺序资源分配法：首先给系统中的资源编号，规定每个进程必须按编号递增的顺序请求资源，同类资源(编号相同的资源)一次申请完

- 缺点
不方便增加新设备，会导致资源浪费，用户编程麻烦
***
### 死锁避免

安全序列：指如果系统按照这种序列分配资源，则每个进程都能顺利完成；只要能找出一个安全序列，系统就是安全状态，安全序列可能有多个
#### 银行家算法

在资源分配之前预先判断这次分配是否会导致系统进入不安全状态，以此决定是否答应资源分配请求

- 算法步骤
1、检查此次申请是否超过了之前声明的最大需求数
2、检查此时系统剩余的可用资源是否还能满足这次请求
3、试探着分配，更改各数据结构
4、用安全性算法检查此次分配是否会导致系统进入不安全状态
***
### 死锁检测和解除

#### 死锁的检测

1、用某种数据结构来保存资源的请求和分配信息
2、提供一种算法，利用上述信息来检测系统是否已进入死锁状态
#### 死锁的解除

- 解除死锁的主要方法
**资源剥夺法**：挂起(暂时放到外存上)某些死锁进程，并抢占它的资源，将这些资源分配给其他的死锁进程；被挂起的进程可能长时间得不到资源而饥饿

**撤销进程法(或称终止进程法)**：强制撤销部分、甚至全部死锁进程，并剥夺这些进程的资源；这种方式的优点是实现简单，但所付出的代价可能会很大，因为有些进程可能已经运行了很长时间，已经接近结束了，一旦被终止则功亏一簧

**进程回退法**：让一个或多个死锁进程回退到足以避免死锁的地步；要求系统要记录进程的历史信息，设置还原点

- 解除死锁进程的选择
进程优先级、已执行多长时间、还要多久能完成、进程已经使用了多少资源、进程是交互式的还是批处理式的
***

