
### 基本概念

- 传统存储管理方式的特征/缺点
一次性：作业必须一次性全部装入内存后才能开始运行(作业很大时，不能全部装入内存，导致大作业无法运行；当大量作业要求运行时，由于内存无法容纳所有作业，因此只有少量作业能运行，导致多道程序并发度下降)
驻留性：一旦作业被装入内存，就会一直驻留在内存中，直至作业运行结束

- 虚拟内存的定义
操作系统虚拟性：实际的物理内存大小没有变，只是在逻辑上进行了扩充

- 虚拟内存的特征
多次性：无需在作业运行时一次性全部装入内存，而是允许被分成多次调入内存
对换性：在作业运行时无需一直常驻内存，而是允许在作业运行过程中，将作业换入/换出
虚拟性：从逻辑上扩充了内存的容量，使用户看到的内存容量，远大于实际的容量

- 虚拟内存技术的实现
虚拟内存的实现需要建立在离散分配的内存管理方式基础上

请求分页存储管理、请求分段存储管理、请求段页式存储管理

操作系统要提供请求调页(或请求调段)功能和页面置换(或段置换)的功能
***
### 请求分页存储管理

- 页表机制
请求页表：页号+内存块号+状态位(是否已调入内存)+访问字段(可记录最近被访问过几次，或记录上次访问的时间，供置换算法选择换出页面时参考)+修改位(页面调入内存后是否被修改过)+外存地址(页面在外存中的存放位置)

- 缺页中断机构
在请求分页系统中，每当要访问的页面不在内存时，便产生一个缺页中断(内中断)，然
后由操作系统的缺页中断处理程序处理中断，此时缺页的进程阻塞，放入阻塞队列，调页完成后再将其唤醒，放回就绪队列

如果内存中有空闲块，则为进程分配一个空闲块，将所缺页面装入该块，并修
改页表中相应的页表项
如果内存中没有空闲块，则由页面置换算法选择一个页面淘汰，若该页面在内
存期间被修改过，则要将其写回外存，未修改过的页面不用写回外存

- 地址变换机构
区别于基本分页存储管理地址变换的细节：
1、只有“写指令”才需要修改“修改位”；并且，一般来说只需修改快表中的数据，只有要将快表项删除时才需要写回内存中的慢表，这样可以减少访存次数
2、和普通的中断处理一样，缺页中断处理依然需要保留CPU现场
3、需要用页面置换算法来决定一个换出页面
4、换入/换出页面都需要启动慢速的I/O操作，如果换入/换出太频繁，会有很大的开销
5、页面调入内存后，需要修改慢表，同时也需要将表项复制到快表中
***
### 页面分配策略

- 驻留集
指请求分页存储管理中给进程分配的内存块的集合，在采用了虚拟存储技术的系统中，驻留集大小一般小于进程的总大小

- 工作集
指在某段时间间隔里，进程实际访问页面的集合；操作系统可以统计进程的工作集大小，根据工作集大小给进程分配若干内存块

- 抖动/颠簸现象
刚刚换出的页面马上又要换入内存，刚刚换入的页面马上又要换出外存，这种频繁的页面调度行为称为抖动/颠簸；产生抖动的主要原因是进程频繁访问的页面数目高于可用的物理块数(分配给进程的物理块不够)
#### 页面分配、置换策略

- 固定分配局部置换
- 可变分配全局置换
- 可变分配局部置换

固定分配：操作系统为每个进程分配一组固定数目的物理块，在进程运行期间不再改变，即驻留集大小不变
可变分配：先为每个进程分配一定数目的物理块，在进程运行期间，可根据情况做适当的增加或减少，即驻留集大小可变

局部置换：发生缺页时只能选进程自己的物理块进行置换
全局置换：可以将操作系统保留的空闲物理块分配给缺页进程，也可以将别的进程持有的物理块置换到外存，再分配给缺页进程
#### 页面调入的时机

- 预调页策略
根据局部性原理，一次调入若干个相邻的页面可能比一次调入一个页面更高效；主要用于进程的首次调入

- 请求调页策略
进程在运行期间发现缺页时才将所缺页面调入内存；由这种策略调入的页面一定会被访问到，但由于每次只能调入一页，而每次调页都要磁盘I/O操作，因此I/0开销较大
#### 页面调入的位置

- 系统拥有足够的对换区空间
页面的调入、调出都是在内存与对换区之间进行，这样可以保证页面的调入、调出速度很快；在进程运行前需将进程相关的数据从文件区复制到对换区

- 系统缺少足够的对换区空间:
凡是不会被修改的数据都直接从文件区调入；由于这些页面不会被修改，因此换出时不必写回磁盘，下次需要时再从文件区调入即可，对于可能被修改的
部分，换出时需写回磁盘对换区，下次需要时再从对换区调入

- UNIX 方式
运行之前进程有关的数据全部放在文件区，故未使用过的页面，都可从文件区调
入；若被使用过的页面需要换出，则写回对换区，下次需要时从对换区调入
***
### 页面置换算法

- 最佳置换算法(OPT)
每次选择淘汰的页面将是以后永不使用，或者在最长时间内不再被访问的页面，这样可以保证最低的缺页率

- 先进先出置换算法(FIFO)
每次选择淘汰的页面是最早进入内存的页面；把调入内存的页面根据调入的先后顺序排成一个队列，需要换出页面时选择队头页面即可，队列的最大长度取决于系统为进程分配了多少个内存块

Belady异常：当为进程分配的物理块数增大时，缺页次数不减反增的异常现象

- 最近最久未使用置换算法(LRU)
每次淘的页面是最近最久未使用的页面；赋予每个页面对应的页表项中，用访问字段记录该页面自上次被访问以来所经历的时间t，当需要淘汰一个页面时，选择现有页面中t值最大的，即最近最久未使用的页面

- 时钟置换算法(CLOCK)/最近未使用算法(NRU)
为每个页面设置一个访问位，再将内存中的页面都通过链接指针链接成个循环队列，当某页被访问时，其访问位置为1；当需要淘汰一个页面时，只需检查页的访问位：
如果是0，就选择该页换出，如果是1，则将它置为0，暂不换出，继续检查下一个页面，若第一轮扫描中所有页面都是1，则将这些页面的访问位依次置为0后，再进行第二轮扫描(第二轮扫描中一定会有访问位为0的页面，因此简单的CLOCK算法选择一个淘汰页面最多会经过两轮扫描)

- 改进型的时钟置换算法
如果被淘汰的页面没有被修改过就不需要执行I/O操作写回外存，只有被淘汰的页面被修改过时，才需要写回外存

将所有可能被置换的页面排成一个循环队列(访问位，修改位)；
第一轮：从当前位置开始扫描到第一个(0,0)的页面用于替换，本轮扫描不修改任何标志位
第二轮：若第一轮扫描失败，则重新扫描，查找第一个(0,1)的页面用于替换，本轮将所有扫描过的帧访问位设为0
第三轮：若第二轮扫描失败，则重新扫描，查找第一个(0,0)的页面用于替换，本轮扫描不修改任何标志位
第四轮：若第三轮扫描失败，则重新扫描，查找第一个(0,1)的页面用于替换

- 页面置换算法对比
![[Pasted image 20240527201954.png]]
***
### 内存映射文件

内存映射文件：操作系统向上层程序员提供的功能(系统调用)

- 内存映射文件的访问方式
open：系统调用，打开文件
mmap：系统调用，将文件映射到进程的虚拟地址空间

以访问内存的方式访问文件数据文件数据的读入/写出由操作系统自动完成进程关闭文件时，操作系统自动将文件被修改的数据写回磁盘

- 内存映射文件实现共享
多个进程可以映射同一个文件，实现共享
***
### 覆盖与交换

用于“解决“程序大小超过物理内存总和”的问题
#### 覆盖技术

- 覆盖技术的实现
将程序分为多个段(多个模块)常用的段常驻内存，不常用的段在需要时调入内存；内存中分为**一个"固定区"和若干个“覆盖区"**，需要常驻内存的段放在“固定区”中，调入后就不再调出(除非运行结束)不常用的段放在“覆盖区”，需要用到时调入内存用不到时调出内存

- 特点
必须由程序员声明覆盖结构，操作系统完成自动覆盖；对用户不透明，增加了用户编程负担；覆盖技术只用于早期的操作系统中
#### 交换技术

交换(对换)技术的设计思想：内存空间紧张时，系统将内存中某些进程暂时换出外存，把外存中某些已具备运行条件的进程换入内存(进程在内存与磁盘间动态调度)

- 交换技术的实现
1、具有对换功能的操作系统中，通常把磁盘空间分为文件区和对换区两部分
2、交换通常在许多进程运行且内存吃紧时进行，而系统负荷降低时就暂停
3、优先换出阻塞进程和优先级低的进程；为了防止优先级低的进程在被调
入内存后很快又被换出，有的系统还会考虑进程在内存的驻留时间
**PCB会常驻内存**，不会被换出外存
***

